# Java IO

### BuffedIO与普通IO 谁更快

BufferIO更快，8K的数据缓冲区.

- ByteBuffer:
  三个指针： pos:读写指针，读写操作开始的指针 limit:读操作时，lim会指向有效数据的最后一位。写操作时，lim=cap cap:buffer分配的内存区容量

## TCP/IP

面向连接的，通信安全的网络协议。

### 三次握手

当客户端与服务器建立连接前需要经过三次握手，来确认通信状态安全。
![三次握手](../../img/IO-TCP-IP-三次握手.PNG)

1. 客户端->服务端发送 `syn`
2. 服务端收到后，向客户端回复`syn + ack`
3. 客户端收到服务端的回复之后，再次向服务端发送确认信号`ack`

三次握手之后，双方可以建立连接了。生成socket，双方在各自的内核空间为此次连接开辟缓冲区`Buffer`。

### Socket

Socket的实质是一个四元组：{ Client_IP,Client_PORT,SERVER_IP,SERVER_PORT }。

- IP: Client_IP与SEVER_IP是标志通信双方主机的
- PORT: Client_PORT与SERVER_PORT标记通信的进程

Socket生成的四元组具有唯一性，这四个字段唯一标识一个通信连接。
![Socket-逻辑模型](../../img/IO-Socket-逻辑模型.PNG)

注： 1. 一个进程可以与多个不同的进程建立通信连接，只要建立连接的Socket四元组不同即可。

![Socket-物理模型](../../img/IO-Socket-物理模型.PNG)
当两个进程进行通信的时候，会生成一个Socket(唯一的四元组)被通信双方分别持有，同时会在内核内存区为本次会话开辟一个内存缓冲区。
该缓冲区用于接受对方传过来的数据。
另外，当我们在程序级别创建了一个Socket的连接，但是没有调用`accept()`方法时，OS依旧会在内核层面为进程做好相应的准备，开辟好缓冲区。
只不过不为本次连接分配进程号。即使我们不调用 `accept()` 方法，也可以接收对方发来的消息，这些消息存在缓冲区中，当缓冲区满时，再发消息就会
被丢弃掉。此时我们调用`accpet()`，会读取缓冲区中已缓存的数据。

## 网络IO变化模型
