# Redis 特性

## Redis 通道

支持多个操作在一次请求中被执行，如果每个操作都需要访问一次redis服务，会带来额外的消耗。  
客户端和服务器通过网络进行连接。这个连接可以很快（loopback接口）或很慢（建立了一个多次跳转的网络连接）。无论网络延如何延时，数据包总是能从客户端到达服务器，并从服务器返回数据回复客户端。

这个时间被称之为 RTT (Round Trip Time - 往返时间).
当客户端需要在一个批处理中执行多次请求时很容易看到这是如何影响性能的（例如添加许多元素到同一个list，或者用很多Keys填充数据库）。例如，如果RTT时间是250毫秒（在一个很慢的连接下），即使服务器每秒能处理100k的请求数，我们每秒最多也只能处理4个请求。

## Redis 发布订阅

![redis 订阅发布](../../img/Redis订阅发布.PNG)

subscribe + publish: redis 会提供一个发布订阅的模式，一个客户端可以订阅一个或者多个通道，当其他客户端在某个通道内发消息的时候，
订阅这个通道的其他客户端都可以收到消息。另外，这个订阅是无关物理存储的，不管你是连接的哪一个数据库，只要订阅了一个通道，那么只要有其他客户端在这个通道上发送消息，你都可以收到。

- 订阅： `subscribe channel [channel...]` 订阅某个通道
- 发布： `publish channel message` 在某个通道上发送消息
- 取消订阅： `unsubscribe channel` 取消订阅某个通道

![redis 订阅发布命令](../../img/Redis-pubsub.PNG)

redis除了提供指定通道的订阅发布，还提供了一种基于通道模式的订阅发布，就是可以订阅符合某个模式的通道

- 基于模式匹配的订阅： `psubscribe pattern` 比如说我们想订阅以xx开头的所有通道，那么可以使用`psubscribe xx*`
- 退订模式匹配：`punsubscribe pattern` 退订该模式的监听，如果没有指定pattern，默认退订所有`psubscribe`指定的订阅

![redis 基于模式匹配的订阅发布](../../img/Redis-模式订阅发布.PNG)

最后，redis还提供了对发布订阅的自检功能，比如想了解一下某个通道的订阅人数，想查看一下当前活跃的通道都有哪些，活跃是指该通道有一个或者多个订阅者。

- 自省命令：`pubsub <subcommand> ... args ...` PUBSUB 是自省命令，能够检测PUB/SUB子系统的状态。它由分别详细描述的子命令组成

![redis pubsub命令](../../img/Redis-pubsub命令.PNG)

这里我验证了一个问题，我一个客户端A使用的是基于模式匹配的订阅,订阅了`xx*` 另一个客户端B订阅了`xx1` 然后我是用`pubsub`命令来查看`xx*`模式下有哪些通道时 只显示了`xx1`，即使我又用了一个客户端C向`xx2`
这个通道发了消息，使用`pubsub`查看时仍然只能看到xx1。所以，这里的活跃通道应该是指被一个客户端显式订阅的，模式订阅的不算。

## Redis 事务

![Redis事务](../../img/Redis事务.PNG)

不支持回滚，redis的特征就是快速，没必要为了强制数据完整性而放弃这个特征。Redis事务以`MULTI`开启，在该命令的所有命令都会被压入队列等待执行，当收到`EXEC`的时候才会将这些命令一起执行。
那么这样就涉及到了多个客户端在进行事务时哪个事务会被先执行的问题了。如上图两个客户端同时向redis服务器开启事务，但是由于redis的文件处理器时单线程，所以这些命令会被顺序排列。 对于多个事务来说，哪个事务先执行`exec`
,哪个事务的所有命令就会被先执行。这样对于后执行的事务来说，可能会造成脏读。比如A事务写下`get k1`时，k1的值可能是3，但是如果B事务先执行了`incr k1`,
那么后执行的A事务是从incr的基础上得到的k1。假如我们不想得到变化之后的k1,我们就想得到没有改变的k1，或者说哪怕知道k1有无改变也能接受。那么，我们可以使用`watch k1`去监视k1的变化。

- watch: 监视key的命令，在开启事务之前就对某个key进行watch，当在事务执行的时候，如果key与监视的时候不一致了，那么本次事务就不会执行。
- multi: 开启事务，客户端通过该命令开启一个事务，在该命令之后的所有命令都会压入一个队列，等待执行。
- exec: 该命令触发并执行事务中的所有命令。当客户端使用`multi`开启事务后，却又与服务端口连接，没有执行`exec`，那么事务中的所有命令都不会执行。 另一方面，当成功开启事务，并且执行`exec`
  ，那么事务中的命令都会被执行。这也是事务的原则，要么都执行，要么都不执行

  > 当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。 然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。 如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。 使用redis-check-aof程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。 从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。

- discard: 当我们开启事务之后，所有的命令都会被压入队列，但是这时候如果我们不想执行事务了，那么我们可以使用`discard`指令来打断本次事务。使用`discard`会清空事务中所有的命令并放弃本次事务的执行。

### 事务错误

在执行事务的过程中可能会出现两种错误：

- 事务在执行`exec`前，入队的命令可能出错，比如语法错误，或者是内存不足等。
- 事务在执行`exec`后，命令在执行的时候出错了。

对于第一种错误，Redis2.6.5之前，redis-cli会对入队的命令的结果进行检查，如果返回`QUEUED`则入队成功，继续。
否则就入队失败，一般来说，如果有命令入队失败，就会取消本次事务。 但是在Redis2.6.5之后。redis客户端会对入队出错的命令做记录，在执行`exec`时发现有出错的命令就撤销该事务。  
对于第二种错误，在 Redis2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。
至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。

### Watch
>WATCH 使得 EXEC 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。 
> WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。
