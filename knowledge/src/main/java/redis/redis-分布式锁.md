# Redis实现分布式锁

## 特性

具备以下三个特性就可以实现一个最低限度可用的分布式锁：

- 安全属性：互斥性，一个锁对象，只能被一个客户端所持有，其他客户端无法持有
- 活性A: 无死锁，必须要保证当一个持有锁对象的客户端崩溃或者是出现网格分裂时，该锁对象可以被重新获取
- 活性B：容错，必须保证大多数redis节点存活时，客户端可以获得锁

## 单节点redis实现分布式锁

要满足安全属性，也就是互斥性的话，我们需要客户端在创建锁对象时，必须确认redis中无对应的key。  
要满足无死锁的话，我们可以为锁对象设置失效时间TTL,这样即使客户端崩溃，也不会导致该锁对象一直存留在内存，导致无法被其他客户端获取。  
至于容错，单节点的redis暂时不考虑。  
因此我们可以通过以下命令来创建一个分布式锁：

```redis
 set lock_name random_value nx ex 30000
```

下面详细介绍一下：key可以认为是锁对象，如果一个客户端可以创建这个key，那么这个客户端就可以持有这个锁了。  
`nx`能当key不存在时才能设定，因此当某个客户端持有这个锁的时候，其他客户端就无法创建了。  
`ex 30000`这个是防止客户端崩溃导致死锁，同时这个也是锁的有效期，客户端需要执行的互斥操作必须在锁的有效期内完成。
`set lock_name random_value`,为什么要给锁的value设置一个随机值呢，其实这个相当于一个签名，假想一下这个场景：  
客户端A获得了锁lock_X，但是由于阻塞，lock_X失效了，被客户端B重新创建了。在客户端B持有锁进行互斥操作的时候，A阻塞结束，
也完成了自己的操作，因此A要释放lock_X，如果这时候A将lock_X删除了，很有可能会导致客户端C又持有该锁，并与客户端B对共享资源同时进行操作。
因此这里设计随机值就是为了防止之前持有过锁的客户端释放了其他客户端的锁。这样，我们可以使用lua脚本再释放锁的时候进行校验：

```lua
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

值得注意的是，这个随机值必须是全客户端唯一的，即每个客户端必须对锁有自己特有的签名，一个比较简单的做法就是： 把以毫秒为单位的时间戳和客户端ID拼接起来，当然这个不是绝对安全，但是大多数情况下已经够用了。

## Redlock算法

聊完了单点redis实现分布式锁，我们可以聊一下基于redis集群如何实现分布式锁，同样针对分布式锁的三个特性：

1. 关于互斥性，如果一个客户端向获取redis集群的锁，同时使其他客户端无法获取该锁，我们该如何实现呢。
   假设redis集群中存在N个redis的redis节点，且每个master节点不存在主从复制等场景。那么我们只要获取的大多数redis节点上的
   的锁对象，这样对同一个锁对象，其他客户端最多只能获取剩下的锁对象，我们设定成功获取大多数锁对象的客户端成功持有该锁。 那么这里最多只有一个客户端能获得这个集群上的锁对象。大多数：N/2+1

2. 关于无死锁，同样是给每个redis节点上的锁对象设置过期时间，但是这时候锁的有效时间就变得不那么确定了。锁的有效时间是集群上的锁对象最短的过期时间。

3. 关于容错，当一个客户端无法获取大多数锁的时候，需要这个客户端释放掉他持有的锁，而不是继续持有。

那么客户端应该进行以下操作来获取分布式锁，假设我们的redis集群中存在5个redis实例：

1. 获取当前的时间戳timestamp
2. 逐个向各个redis实例获取锁，使用单体redis分布式锁的方式，以相同的key和随机值获取锁对象，另外客户端需要设置一个redis连接的超时时间。
   比如说，我们设定的过期时间是10秒，那么超时时间应该设为10-50ms。这样可以避免redis服务挂掉而使客户端死等回应。客户端应该再尽量短的时间内 获取到尽可能多的实例上的锁对象
3. 客户端的每拿到一个锁对象，用当前时间减去记录的时间戳timestamp，得到锁的使用时间，当获得的大多数实例（这里是3个实例）上锁的使用时间都小于锁的有效时间时， 那么我们可以认为是客户端成功获取了锁。
4. 如果获取到了锁，那么锁真正可使用的时间=锁的有效时间-锁的使用时间。
5. 如果客户端没有获取到大多数实例上的锁对象，那么需要在所有redis上释放锁，即使在某些redis上没有获得过锁。

> 算法基于这样一个假设：虽然多个进程之间没有时钟同步，但每个进程都以相同的时钟频率前进，时间差相对于失效时间来说几乎可以忽略不计。这种假设和我们的真实世界非常接近：每个计算机都有一个本地时钟，我们可以容忍多个计算机之间有较小的时钟漂移。  
> 从这点来说，我们必须再次强调我们的互相排斥规则：只有在锁的有效时间（在步骤3计算的结果）范围内客户端能够做完它的工作，锁的安全性才能得到保证（锁的实际有效时间通常要比设置的短，因为计算机之间有时钟漂移的现象）

### 失败时重试

当客户端无法成功获取锁的时候，应该在随机延时一段时间之后再次尝试获取锁。假如多个客户端同时争夺同一个资源的锁，比如说5个redis节点的同一把锁，被A,B，C三个客户端争夺，A,B,C分别获取2，2，1个节点上的锁，这时候谁也无法获得大多数节点上的锁，
如果继续争夺并且持有锁，会造成谁也获得不到锁，产生脑裂（关于脑裂，我觉得是一种集群无法决断某个时间而出现的问题，或者归结到无法形成决定性势力范围而导致的）。所以失败重试需要做两件事：

1. 释放当前自己持有的锁
2. 在随机延时一段时间后，进行重试  
   这样的话，A,B,C在都获得不了锁之后，释放他们各自持有的锁，然后随机延时短的客户端会先开始尝试获取锁，在下一个客户端延时结束之前（如果没有新的客户端加入竞争），大概率可以获取到锁的。另外，客户端获取大多数节点锁用的时间越短，脑裂出现的概率越低。
   需要强调的是，客户端在获取不了大多数节点的锁的时候，应该尽快释放掉自己持有的锁，这样其他客户端可以尽快获取锁，当然，如果客户端与某个redis节点出现了网络断裂而导致无法释放掉锁，那么就只能等待这个锁自己失效了，这样相当于被惩罚了。
   
> 系统的活性安全基于三个主要特性:
>1. 锁的自动释放（因为key失效了）：最终锁可以再次被使用.  
>2. 客户端通常会将没有获取到的锁删除，或者锁被取到后，使用完后，客户端会主动（提前）释放锁，而不是等到锁失效另外的客户端才能取到锁。.
>3. 当客户端重试获取锁时，需要等待一段时间，这个时间必须大于从大多数Redis实例成功获取锁使用的时间，以最大限度地避免脑裂。.


