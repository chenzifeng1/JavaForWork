# Redis集群

## AKF原则

AKF原则是指在进行分布式服务扩容时的三个维度，我们可以通过在这三个维度上来进行扩展使系统的性能得到提升。  
AKF原则主要解决了分布式服务的一些问题：

1. 单点问题
2. 容量
3. 连接数

三个方向的扩容原则 ：

- x: 复制扩展
- y: 基于功能拆分扩展
- z: 基于用户扩展

以 Redis服务 为例：

- x方向： 在此方向上的扩展可以解决单点问题
    - 主从： 职能分离，从节点不可代替主节点。一般主节点可以进行读写操作，而从节点只提供读操作。主节点需要向从节点进行数据备份。可以解决连接数问题
    - 主备： 备用服务节点一般不启用，只是在主节点出问题时，启动代替主节点，备用节点的功能与主节点完全相同。解决不了连接数问题，只能解决单点问题
- y方向： 在此方向上的扩展可以解决连接数问题
    - 功能拆分，将不同业务缓存到不同的redis节点上，这样单个redis上只接收部分业务的请求
- z方向：对同一块业务的数据进行分库分表

## CAP原则

在分布式系统中，`数据一致性`,`可靠性`,`分区容错性`三者最多同时满足两个条件。

## Redis集群配置

### 手动配置

比如说我们本机启动三个redis服务，首先启动一个端口为6379的redis服务：
`redis-server redis`

### sentinel 哨兵机制

### redis集群寻找数据的算法

cluster的模式： 无主模式 客户端不需要去管数据在哪个实际节点上，想连谁连谁，只不过如果我连接的节点如果没有我想要的数据，那么会这个节点会告知我应该去哪个redis上获取数据。
这是每个redis节点除了知道自己加载了那些槽位的数据外，它还知道通过一个hash定位算法，就是这个key扔进来，我可以计算出它现在应该在哪一个槽位上。
这样的话，其实就无所谓访问哪个了。我只要告知client应该去哪个redis节点上找数据，就完事了。 步骤就是：

1. 客户端先访问一个redis节点，如果需要访问的数据就在这个槽位上，那么我就返回这个数据。
2. 如果需要的数据不在我这个节点加载的槽位上，那我就计算一下，看看他是在哪个槽位上。然后把这个槽位告知客户端
3. 客户端重定向到对应的槽位去拿数据。

- 数据分治的时候会必然有一个问题：聚合操作难以实现。比如说事务，比如说两个不同节点上的set取交集。 因为这里会存在一个问题：就是数据移动的问题，因为redis追去的是性能，是速度，所以一般都是计算向数据移动，而不是移动数据去做计算。
  当然啦，redis不去做这个数据的聚合操作，但它给我们提供了一种方式，就是只要我们想办法把数据放在同一个节点上，这样的话，就可以进行操作了。 所以他提供了，`hash tag`
  ,具有相同tag的key会被映射到同一个槽位上，这样的话我们就可以进行数据聚合操作了。

`hash槽`   
redis集群有16384个hash槽，每个key经过crc16校对之后，然后对hash槽取模知道会被映射到哪个hash槽上去了。
这种结构的话很容易添加或删除节点，增加节点的时候，只需要新节点来分担之前节点的部分槽位即可，旧的节点把槽位对应的数据加载到新的节点上就可以了。
移除节点的话，就是先将要移除的节点上的槽点分担到其他节点上，然后直接删除这个没有槽位的节点就行了。

## redis主从复制模型
一般为了让redis集群有更高的可用性，在配置集群的时候一般都是使用主从复制模型的。这样即使我的主节点挂了，
集群会推举从节点上的一个节点作为主节点来使用。这样集群就不会因为主节点挂了而导致某些槽不可用了，当然如果从节点全挂了，那这样集群就不可用了。

## redis一致性保障


   