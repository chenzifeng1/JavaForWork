# MySql 调优

从三个层次了解mysql

1. Client
2. Server： 连接器  
   ->分析器（对sql语句进行语法分析，构成一个AST,抽象语法树）  
   ->优化器（两种优化方式，RBO 基于规则的优化/CBO 基于成本的优化） ->执行器（sql语句实际执行的组件） mysql8.0之前存在缓存这一层，但是由于命中率不高在8.0版本移除了
3. 存储引擎

## 性能监控

- 使用 `show profile`查询剖析工具，可以指定具体的type 见官网文档[mysql性能](https://dev.mysql.com/doc/refman/8.0/en/performance-schema.html)
- 使用`performance_schema`

## 说一下数据库索引原理，底层索引数据结构，叶子节点存储什么，索引失效的情况

聊数据库的话主要是从两个角度上来回答

1. IO角度：
    1. 尽量减少数据请求，一个是指数据请求的次数，一个是指请求数据的数量。
    2. 分块读取： 每次读页的整数倍
    3. 局部性原理：空间局部性

2. 数据结构： 为什么使用B+树，二叉树，AVL树，红黑树都是二叉树，数据量多会引起树的深度增加。 B树与B+树区别是 B树的节点中既有key，又有数据，且B树的key是不重复的。
   比如说我插入了10个记录，那么就是生成了10个数据节点（B树会根据树的度来生成节点）。 但是，B+树上，所有数据都是存储在叶子节点的，非叶子节点上只存储key

### MMM MHA MGR

### 水平分库 水平分表 垂直分库 垂直分表

就一个表而言，水平分是指一条记录不拆分，只不过是所有记录进行分片，按照范围。 比如说每个月的数据放到一个片里面。 垂直分是指将记录拆开，拆成更小的业务单位。或者说可以将常用的列抽出来形成一张新表，
而不常用的列可以作为另一张表。需要全查的时候做联查就行。

在进行分库分表的时候尽量遵循以下几个原则：

1. 能不切分尽量不要切分，除非数据量很大的时候（千万级别）或者说表的列很多，当百万级别的数据就占用了很大空间的时候。
2. 如果要切分一定要选好合适的切分规则，提前规划好
3. 数据切分尽量通过数据冗余或者表分组来降低跨库join的可能性
4. 由于数据库中间件对数据join的实现难以把握，且实现高性能难度极大，业务读取尽量少使用多表join

### 主从复制 读写分离

主从复制是读写分离和分库分表的前提

### 数据库引擎

可以使用`show engines`来查看对应的数据支持的引擎,介绍三个主要的引擎

- MyISAM: 原生数据库引擎
- MEMORY: 基于内存的数据库引擎
- InnoDB: 插件式数据库引擎

对比 MyISAM和InnoDB:

|对比项   | InnoDB | MyISAM |  
| ------ | ------ | ------ |  
| 事务    |支持    | 不支持  |
| 外键    |支持    | 不支持  |
| 索引    |支持聚簇索引和非聚簇索引|只支持非聚簇索引 |
| 行锁    |支持     |不支持   |
| 表锁    |支持     | 支持    |
| 存储文件 |frm,ibd |frm,myi,myd |
| 具体行数 |每次必须要全表扫描统计行数|通过变量保存行数|

## 数据库调优：

1. 数据库连接问题
2. 数据库表设计
3. 数据库的索引设计
4. SQL语句的设计问题
5. 数据库的参数配置问题

## 描述一下聚簇索引和非聚簇索引的区别

两者都是索引的一个基本分类，两者最本质的点在于**存储引擎**,如果我们使用的是`InnoDB`这种存储引擎， 由于它的存储文件是`.frm`和`.idb`，存储数据文件和索引文件的都是`idb`，也就是说两者是存在同一个文件中的。
而数据在实际存储的时候不可以有大量冗余，所以数据和索引绑定存储的索引叫做聚簇索引，数据和索引分开存储的索引叫做非聚簇索引。 像`MyISAM`这种存储引擎，它的存储文件包含了`myd`和`myi`
，它的索引和数据是分开存放的，所以它只支持非聚簇索引。  
一个表可以有多个索引，这也就意味着这个表会形成多颗B+树，但是不能所有的B+树都存放全量数据，这会导致大量数据冗余。 因此，和数据存放在一起的叫做聚簇索引，其他的索引存放的是聚簇索引的key值，通过回表的方式来查询数据。

InnoDB在进行数据插入的时候，必须将数据绑定在一个索引列上，默认是主键，如果没有主键就是用唯一键，没有唯一键就自动生成一个6位的row_id，
和数据绑定在一起的索引成为聚簇索引。没有和数据绑定在一起的索引成为非聚簇索引。根据普通索引构建的B+树中，叶子节点key是普通索引的key， value是对应的聚簇索引的key值。

## 索引失效条件

1. 违反最佳左匹配原则
2. 使用不等于 !=,<,>
3. like "%str"
4. 索引列上进行计算操作
5. 组合索引中，中间的某一列使用了范围搜索，会导致该列右边的索引失效
6. 尽量少使用 or
7. 字符串不加单引号，索引失效
8. 当全表扫描效率大于使用索引的时候，索引失效

## 事务有哪些隔离级别 分别解决了什么问题

- 脏写 本质上是一个事务把另一个事务的写操作给回滚了 为了解决脏写，数据库将事务隔离级别设为**读未提交**，在一个事务提交之前，其他事务无法对这个事务的数据做修改。
- 脏读 本质上是一个事务读取到了另一个事务未提交的数据，为了解决脏读，数据库将事务隔离级别设为**读提交**，即在事务读数据时，只能读取其他事务已经提交过的值，对于事务未提交的值是读不到的。
- 不可重复读 本质上是一个事务多次从数据库读到了不同的值，要和脏读区分开来（脏读是读到了未提交的事务的值），不可重复读是读到了提交事务的值 对应的事务隔离级别是，可重复读是指 一个事务在多次向数据库读取数据的期间读到的数据是一致的。
- 幻读 一个事务内两次读取获取到的数据条数是不一致的，读到了之前自己没有读到的数据。 事务隔离级别:串行化

## 描述一下mysql主从复制机制的原理，主从复制主要有几种模式？

主库每次写入数据的时候会生成一个binlog(二进制日志)文件，从库中会有个IOThread定时去主库读取这个binlog,然后将这个bin_log放入
relay_log中，由SQLThread来调用relay_log将日志执行到从库中去。

为什么要有bin_log和relay_log，尽量使用顺序IO避免随机IO。

模式：

1. 一主一从
2. 主主复制
3. 一主多从

## 如何优化SQL，查询计划的结果中看哪些关键数据

查询计划 explain 1、执行计划中包含的信息

|Column|Meaning|
| ----|----|
|id |The SELECT identifier|
|select_type |The SELECT type|
|table |The table for the output row|
|partitions |The matching partitions|
|type |The join type|
|possible_keys |The possible indexes to choose|
|key |The index actually chosen|
|key_len |The length of the chosen key|
|ref |The columns compared to the index|
|rows |Estimate of rows to be examined|
|filtered |Percentage of rows filtered by table condition|
|extra |Additional information|

主要看以下几个点：

- select_type: 主要来查询类型，是简单查询，还是复杂查询。
- type: type显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：  
  system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range >
  index > ALL  
  一般情况下，得保证查询至少达到range级别，最好能达到ref
- key: 重要，查看实际使用的索引
- key_len: 查看索引使用的数据长度，单一索引时意义不大，组合索引时比较有用
- rows: 查询时候需要遍历的行数，

## b+树查询过程和结构

B+树是基于B树进行的一种优化：

1. B+树的每个超级节点其实是一个数组，包含了多个数据节点，这样做的好处：1. 可以有效降低树的高度，2.将数据范围变为多个区间，区间越多，检索速度越快。
2. B+树的非叶子节点只存key（主键），叶子节点存key和数据
3. 叶子节点使用的是双向链表（为了符合磁盘预读），顺序查找会更加方便。

注意：B+树存在两个指针,一个指向根节点，另一个指向key值最小的叶子节点。 且所有叶子节点之间是一种链式环结构，所以可以对B+树进行两种查找方式：

1. 从根节点开始的顺序查找和分页查找
2. 直接遍历叶子节点的随机查找

![mysql b+树](../../img/mysql_b+树.png)

## 一个sql语句执行流程

两种解答方式：

## 事务隔离级别

1. 读未提交
2. 读提交
3. 可重复读
4. 串行化

##  

## 字符和字符串

1. char： 
   - 固定长度，且最大不超过255
   - 会自动删除末尾的空格，注，末尾空格好像不影响查询，查询的适合默认匹配非空字符串。
   - 检索效率，写效率要优于varchar，空间换时间
   - 应用场景:
   
   1. 存储长度波动不大的字符串：md摘要
   2. 存储短字符串，经常更新的字符串
2. varchar：
    - 使用满足需求的最小长度
    - varchar(n) n小于等于255的时候，使用额外一个字节的保存长度，当大于255的时候需要使用额外2个字节来保存长度
    - varchar(5)跟varchar(255)磁盘占用空间相同，这里因为在磁盘读写的时候是以一个物理块为单位进行的。但是内存占用空间是不同的。
    - 在mysql5.6之前，varchar变更长度，从小于等于255->大于255或者是从大于255->小于等于255都会触发锁表操作。
    - 应用场景：

    1. 存储长度波动比较大的字段，比如文章
    2. 字符串很少更新的场景，每次更新完成之后都会重新计算长度，并且使用额外空间来保存长度
    3. 适合保存多字节字符，如汉字，特殊字符
3. text/blob 用于储存很大的数据，一般情况不会用，如果要存很大的数据，可以存在文件中，然后将路径放到数据库字段上。

### 数据库枚举
```sql
create table enum_test(animal enum("dog","cat","bird","fish"))
```
显示时可以是对应的枚举类的字符串，但是实际上存储的是整型类型，且匹配适合可以使用整型或者字符串来做匹配。

### 


