# 索引

## 索引底层实现

### HashTable
![hashtable](../../img/mysql/hashtable.PNG)  

hashtable对等值查询比较友好，但是对于范围查询，需要对每个元素进行重遍历来定位，而在生产中范围查询出现的频率又是比较多的。
当然啦，对于大部分存储引擎来说，不支持HashTable格式的索引，目前只有Memory支持HashTable索引。

### B+树 
InnoDB和MYISAM索引底层实现的数据结构都是B+树，为什么要选择B+树，我们可以通过对比其他数据类型来得到答案。
- 二叉搜索、二叉平衡树、红黑树

 1. 二叉搜索在插入数据时可能会造成数据倾斜问题，在最坏情况下甚至可能会退化成链表结构。
 2. 二叉平衡树会通过旋转来调整树的结构，但是问题是这种旋转带来的开销比较大，如果大量的插入或者删除造成频繁的旋转，那么总体而已， 插入或者删除时的效率难以接收。二叉平衡树对查找会比较友好，查找的时间复杂度为O(logn)。
 3. 红黑树，通过增加颜色来降低旋转的次数，红黑树可以接受最大树深在最小树深两倍的范围内。

这三种树有个通用的问题，即孩子节点只有两个，即树深度会随着数据量的增加而增加，虽然每一层所能包含的数据量都是上一层的两倍， 但是树的高度依旧会比较大，这样在遍历时的代价可能就会很高。

- B树 
  谈B+树之前我们可以先了解一下B树，看一下B树相对于二叉树有什么优势，而又有那些问题所以让存储引擎最终选择了B+树
 
  1. 相比于二叉树，B树可以有多个孩子节点，且每个孩子节点是一个特殊的数组，或者叫做由多个数据节点做成的超级节点。
  每个非叶子节点都包含三类数据：    1. 指针数据，指向某个磁盘块 2. key，这个是索引列的值，B树/B+树是根据索引来构建的。 3. 数据，对应记录的值。
  2. B树的叶子节点存放的都是数据，没有指针。当定位到叶子节点的时候，要么找到数据返回，要么数据不存在找不到。   

  ![B树](../../img/mysql/B树.PNG)

  实例图说明：  
  每个节点占用一个磁盘块，每个磁盘块上包括三个指针和两个升序排列的关键字。指针存储的是子节点所在的磁盘块的地址，两个关键词划分三个范围。
  范围域对应三个指针。以根节点为例，两个关键字12，25可以划分为`小于12`,`大于12且小于25`以及`大于25`。  
  查找关键字12的过程如下：  
  1. 通过根节点找到磁盘块1，读入内存（第一次磁盘IO操作）
  2. 比较关键字12与13的关系，得到12可能在磁盘块2上,对应p1指针。
  3. 通过磁盘块的p1找到磁盘块2，读入内存 （第二次磁盘IO操作）
  4. 比较关键字与4，10的关系，得到数据可能在磁盘块7上，对应p3指针。
  5. 根据p3得到磁盘块7,读入内存 （第三次磁盘操作）
  6. 从磁盘块7中找到关键字12,获取到对应的记录。
  
  缺点：这边有个关键性的问题，由于B树的非叶子节点上存储内容包括数据，由于OS有个机制叫做磁盘预读，可能为了读某条数据而把整个磁盘块的数据都读到内存中。
  这样的话，假设每次磁盘预读一个块的数据，假设一个块是16K（可能是4K）,如果极端情况下，指针不占用存储空间，且一条记录（key+data）占用空间是1K，即
  每个块上只包含`16`条数据，那么如果我们通过3次磁盘IO所能获取到的数据条数应该是多少呢。第一次磁盘IO，我们可以得到16条记录以及对应的16个指针域。
  下一次磁盘IO基于16个指针域我们又可以获得`16*16=256`条记录。第三次磁盘IO我们可以选择的数据条数则成了`256*16=4096`条记录。所以可以遍历的条数
  

    
   