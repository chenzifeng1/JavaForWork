1. 项目经历
2. 基础知识

## 浩鲸科技
- 一面
说一下项目经历，说的很乱
  
问题：
1. 说一下HashMap 初始化值是10，容量是多少
考察的是tableSizeFor()方法，容量是大于初始值的最小的2的次方
   
2. 说一下ConcurrentHashMap能不能用size()方法
不能用，因为size方法返回的值是int，ConcurrentHashMap容量是可以超过int的最大值的。 `concurrentHashMap.mappingCount();`
3. 说一下过滤器（Filter）和拦截器（Interceptor）的区别 
   1. 拦截器是基于java的反射机制的，而过滤器是基于函数的回调。
   2. 拦截器不依赖于servlet容器，而过滤器依赖于servlet容器。
   3. 拦截器只对action请求起作用，而过滤器则可以对几乎所有的请求起作用。
   4. 拦截器可以访问action上下文、值、栈里面的对象，而过滤器不可以。
   5. 在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。
   6. 拦截器可以获取IOC容器中的各个bean，而过滤器不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。
   问题扩展：servlet与spring框架
      
4. Mysql索引失效的场景，左模糊匹配如何使用索引
   
5. 聊一下AOP，以及如何实现用户登录计数
 使用`@After`注解在登陆成功之后进行统计
6. redis持久化方式

7. 聊一下CPU剧增问题的排查方案。 
   按照GC排查问题说的。我说CPU剧增的话估计是某个线程中出现一些十分消耗CPU计算资源的问题了。那可能是出现了某些计算的死循环。
   然后出现计算死循环的话还可能引起内存升高。这样的话，可以用jmap -dump导出堆存储文件，然后放到mat上看一下。看看哪个线程占用资源最多，
   然后再找到对应的代码，看看有没有问题。当然，在生成环境下，一般突然剧增也可能与新提交的版本有关，可能是因为新的版本的问题带来的。
   所以可以先排查一下，新版本中有没有做什么改动

8. 说一下mybatis怎么分页
   - limit #{offset},{pageRow}
   - IPage<T> page = new Page<>(pageNum, pageRow); 使用自带的page()方法，传入设定好分页的page对象和查询条件
   
## 一些mq为什么不支持任意时间维度的延时消息

## mysql的锁
分维度：
1. 锁的性质：排他锁和共享锁 在加排他锁/共享锁之前需要加 意向排他锁/意向共享锁
2. 粒度上：表锁和行锁（InnoDB）
3. 乐观锁（CAS ,update set x=x-1 where x = 1）; 悲观锁，显示加行锁
## redis中数据类型的底层实现

## 事务隔离级别
InnoDB 默认可重复读 已经解决了脏读，不可重复读，但是没有解决幻读
除此之外还有*串行化*和*读提交*以及*读未提交*

## 为什么HashMap扩容是2的幂数
因为Hashmap计算存储位置时，使用了(n - 1) & hash。只有当容量n为2的幂次方，n-1的二进制会全为1，位运算时可以充分散列，避免不必要的哈希冲突，
所以扩容必须2倍就是为了维持容量始终为2的幂次方。

## 一个是索引设计题
200W用户订单数据 ，所用到的字段id,user_id,date,让你设计索引，满足某个用户一天的订单查询，某个用户三个月的订单查询，以及所有用户一天的订单查询

## Redis底层数据结构
1. String: 对于string类型的字符串，其底层编码方式共有三种，分别为int、embstr和raw。
      - int:当存储的字符串全是数字时，此时使用int方式来存储；
      - embstr：当存储的字符串长度小于44个字符时，此时使用embstr方式来存储；
      - raw：当存储的字符串长度大于44个字符时，此时使用raw方式来存储；
2. Hash: 字典 + HashTable 
3. Sorted Set: 跳表


### 为什么 Redis 要用跳表来实现有序集合而不是红黑树？
Redis有序集合里面支持的操作有以下几种：
1. 查找单个节点，增加单节点，删除单节点
2. 按照区间查找数据
3. 迭代输出有序序列

对于单节点的增删查来说，红黑树的时间复杂度与跳表相似都是O(n)。  
但是对于区间查找来说，红黑树没有跳表高效，跳表可以在O(logn)时间复杂度下定位到区间起始节点，之后就是沿着链表进行顺序遍历的过程了。
除此之外，跳表相比与红黑树还有实现简单，可读性好，不易出错等优点。因为平衡树和红黑树在插入或者删除节点的时候都可能引起子树的旋转来保持树高的平衡。

## Session和Cookie的区别

1. Http是无状态的协议，因此需要一种机制来保持用户的登录状态，因此Session就是这种维持用户登录会话的机制。
Session是一种逻辑上的概念，表示客户端与服务端所建立的会话。session有个唯一id在服务端标志用户的信息，session可以存在内存，数据库或者文件中。
2. Cookie是客户端来寻找存储用户信息的session的，Cookie中存有sessionId,客户端在向服务端发起请求的时候，会带着这个cookies。
3. 如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。

## 重定向原理

客户端向服务端发送一个请求，服务端再根据请求路径匹配的时候，可能觉得用户需要去访问另一个路径。
然后服务端会在响应报头中设置302（临时）/301(永久)的状态码，然后将响应报头中的Location设为要进行二次访问的路径。
客户端接受到这个响应之后，就会向Location中的uri发起第二次请求。

## HashMap中的get/set




### 你觉得项目难点在哪里，你是怎么解决的？

1. 并发量高
   1. 提高单机性能
      1. 硬件性能：加内存，加CPU  预计（64核+256内存）
      2. 软件性能：
         - 选择面向吞吐量的垃圾回收器:Serial Scavenge (CMS和G1都是对响应时间比较友好的) 而且我们系统与用户交互的需求比较少，后台运算的需求很大。
         - 使用redis缓存，减少数据库IO ：缓存热点数据
         - MQ进行流量削峰：可能遇到如何解决消息重复消费问题
         - 从业务层面进行优化
   2. 尝试改造成分布式的，将并发量比较多大的业务模块抽离出来搞成集群，分担单机压力
      1. 可能遇到的问题：如何保证分布式环境下缓存一致性问题，业务操作是要向redis和db写数据的。 根据cap原则，无法保证强一致性，只能保证最终一致性 
         1. 延时双删
         2. canal： 将自己伪装成mysql从节点，同步binlog，然后更新到缓存上
      2. 分布式业务拆分原则：AKF x,y,z轴含义
      3. 分布式事务： 1.两阶段提交 -> seata
2. 数据量大，shardingSphere做数据分片
  1. 水平分表 ： 根据时间使用 标准分片策略 
  2. 垂直分库 :  数据量大的业务数据及关联查询数据放在一个库，其他基础数据放在另一个库




