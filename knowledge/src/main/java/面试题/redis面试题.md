# Redis 面试题

## 介绍一下项目中redis的使用场景

1. 从redis的五种类型说起，String,List,Hash,Set,ZSet。如果项目中有用到的话可以聊一聊： String->bitmap 存储油站控制器离线情况 Set->油站字典 Hash-> （油站基础信息）
2. 缓存，缓存热点数据，比如说油站基础数据， 待匹配的交易数据。 redis主要是用来做缓存，因为它快速，追求性能。 因此可以适当放弃一些数据一致性的要求。
3. 使用redis来实现服务的无状态，这个不好说。

## redis是单线程还是多线程的

1. 首先要明确，不管什么版本，redis的工作线程都是只有一个。
2. 高版本中，6.x以上的redis，提供了多个IO线程来加快数据IO效率，可以更好压榨操作系统和硬件（如网卡）的能力。  
   ![redis 单工作线程模型](../../img/Redis-单工作线程.PNG)  
   首先明确一个事情，redis作为一个服务，是从内核的缓冲区将需要的数据搬运到自己的内存的。而OS的内核中使用的IO模型一般都是多路io选择器的模型。 其中又以epoll这个选择器更为优化。  
   客户端C1,C2是先与OS建立socket连接，然后有数据来的时候，epoll就会读到这写IO事件，注，epoll只负责获取读写事件，不负责事件处理和数据读取。
   redis的工作线程从epoll得知了有哪些客户端发来数据了，然后就会取内存缓冲区中把这些数据搬运到自己的内存中。  
   另外我们可以认为一个redis的一个单指令的执行是原子的。而单指令又可以分为三个步骤：input，计算和output。

   ![redis 多IO线程模型](../../img/Redis-单工作线程多IO线程.PNG)
   在高版本中（6.x）中，redis抽出了多个IO线程来处理IO事件。这样的话，从客户端获取数据和将数据写回的操作都交给IO线程来做。 而在工作线程上只发生计算行为。
   设想一下，同样是两个客户端并发访问redis，在低版本中，每个指令的三个操作都是由工作线程来完成的。 工作线程从epoll上知道两个客户端发来请求了，但是他需要一个个的去缓冲区拿数据，放到自己的内存中，发生计算，然后在放回去。
   但是，现在有两个IO线程可以帮我们来处理IO事件了。工作线程从epoll中得知两个客户端有发来数据，然后指定两个IO线程取读取数据，
   IO线程将读到的数据放到堆上（栈独享，堆共享）。然后工作线程拿到数据发生计算，然后再放回，IO线程得知计算完了之后，将结果返回。

   多个IO线程的优势：
    - 更大限度上压榨了OS和硬件的能力，因为数据是先放到网卡缓存，然后进入内存的Queue，之后被搬运到程序内存中的。多个IO线程提高了这个过程的吞吐量。

   关于执行顺序：redis可以保证一个客户端提交的指令顺序执行，但是无法保证多个客户端提交的指令的执行顺序，因为这个IO线程先读哪个指令无法保证。

## 缓存击穿，穿透，雪崩的解决方案

简述一下，具体看 [Redis 解决缓存问题](../redis/redis-解决并发缓存问题.md)

- 击穿：DB存在这个key，但是失效了（过期或压根没存），针对这个key大量请求打过来，击穿了缓存层，落到数据库上。  
  解决措施： 1. 尝试获得key 2. 获取不到key，去获取锁 3.1 拿到锁，去数据库拿，放缓存 释放锁，3.2 拿不到锁，随机睡眠/降级返回。 4 重试，重复1-3过程。

- 穿透： 数据库压根没有这个key，缓存中也不会存在这个key。 解决措施：
    1. 类似击穿方案，只不过获取锁的线程再查不到数据的时候将 key null 放入缓存。
    2. 布隆过滤器，概率性过滤，可能存在误判。另外只能数据删除或者变动时无法将之前的映射消除。因为不知道是否有其他key也映射到了bitmap上的这一位。 可以使用布谷鸟过滤器。

- 雪崩： 大量的key失效，可能每个key的访问量不大，但是多个key加载一起就很大了。 解决措施：
    1. 不涉及到时点失效的，可以使用随机过期时间
    2. 涉及到随机失效的，只能是使用强依赖的击穿方案。就是使用锁来解决击穿的方案，但是需要结合业务。

## Redis如何淘汰过期的keys

Redis有两种淘汰过期keys的方式：主动和被动

- 被动： 当客户端访问某些key的时候，redis会先检查这些key是否过期，如果过期了就将这些key移除
- 主动： 只靠客户端访问来被动发现过期的key是不够的，因为可能有些key永远也不会被访问，因此redis还提供了主动去寻找过期key并进行淘汰的策略。 以下是redis主动检测的步骤：每10s一次
    1. 随机抽取20个key进行检查是否过期
    2. 移除所有过期的key
    3. 如果过期的key的比例超过25%，重复进行步骤1。

## 缓存预热

提前放入预测的热点数据，但是不可能把所有数据都放入缓存。因此即使进行缓存预热也可能存在缓存击穿，穿透和雪崩的问题。 解决策略见对应问题

## 数据库与缓存不一致怎么办

1. 客户端先写数据库再写缓存，但是如果客户端写完数据库就挂了，就会导致redis和数据库的数据不一致了，因此这样搞不太合适。
2. 先将数据放入mq，消费的时候并发向数据库和缓存写。  
   进一步：双删+补偿。如果有一端写失败了，同时在两个地方删除这一次修改。之后将消息进行数据回池，重新放入队列中。
3. canal 根据数据库的binlog对缓存进行数据同步。canal会将自己伪装成一个数据库从库，然后向主库注册之后。每次主库更新时通过binlog来将修改同步到redis中

## 简述一下主从不一致的问题
这个问题怎么聊呢，先聊一下redis下面两个问题：

## redis持久化原理
1. save: 阻塞式同步，阻塞当前redis进程，然后将数据同步到磁盘上
2. bgsave: fork(),创建一个子进程进行同步，这涉及到操作系统创建子进程的一些东西，包括父子进程对数据的共享，写时复制机制。
## redis持久化方式
1. RDB: 快照，定时生成数据快照。同步的时候子进程会将快照数据落到磁盘或者是从redis节点中。  
   但是这里有问题，就是数据丢失比较多，如果没有触发快照阈值，那在上一次快照和当前时间内的数据都会丢失。  
   快照阈值可以通过配置文件中参数来修改。   
   优点： 数据文件相对较小  
   
    > RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集.
    RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心或者亚马逊的S3（可能加密），非常适用于灾难恢复.
    RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能.
    与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些.
   
    工作方式：
    Redis 
    1. 调用forks. 同时拥有父进程和子进程。
    2. 子进程将数据集写入到一个临时 RDB 文件中。
    3. 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。

  
2. AOF: 通过记录操作到日志文件的方式进行数据备份，数据丢失较少，但是有个问题，就是不断的追加操作记录，会让日志文件变得很大。
    在4.0之前的时候，如果日志文件过大会进行重写来压缩日志文件，配置文件中有两个参数，来指定日志文件多大之后进行重写，还有变大多少倍之后进行重写。  
    4.0之后可以采用RDB+AOF的方式，将时点数据记录快照，时间之间的数据使用AOF的方式进行追加。
   
    >使用AOF 会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync.使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户端请求),一旦出现故障，你最多丢失1秒的数据.  
    AOF文件是一个只进行追加的日志文件,所以不需要写入seek,即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令,你也也可使用redis-check-aof工具修复这些问题.  
    Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。  
    AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。

3. 混合使用的时候，redis优先使用aof文件来进行数据恢复。因为aof的数据相对较全。

## redis事务
watch multi exec


### redis 数据结构底层实现
- String:
- list: 
- hash
- set
- zset