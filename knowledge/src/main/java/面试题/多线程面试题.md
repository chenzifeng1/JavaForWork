1. 如何预防死锁

    死锁产生的四个必要条件：
    1. 互斥条件：同一时间只有一个线程能获得资源
    2. 不可剥夺条件： 当一个线程已占用某个资源，在它释放该资源之前，其他线程无法抢占
    3. 请求与保持条件：线程等待过程中不会释放自己持有的资源
    4. 循环等待条件：多个线程之间相互等待对方的资源被释放  
    
    如何预防死锁：破坏四个必要条件中的一个即可，但是破坏不同的条件代价是不一样的。
    银行家算法，预分配资源，资源分配不到的就等待
   
2. 创建线程的方式
    1. 实现 Runnable 接口 重写run()
    2. 实现 Callable 接口 重写call()
    3. 继承 Tread类。
    4. 扔到线程池中，7个参数
    
    注：这里可以聊一下Future这个类
   

3. 描述一下线程安全活跃态问题，竞态条件
 - 线程活跃态问题可以分为死锁，活锁，饥饿；
   1. 线程死锁： 见上面
   2. 线程活锁： 线程中某些操作陷入死循环，一直无法结束。比如说写了一个`while(true)`但没有对应的`break`跳出条件。或者说递归的时候没有设置递归基，
      导致递归无限进行下去。
   3. 线程饥饿： 某些高优先级的线程总是占用CPU资源，导致低优先级的线程一直无法得到执行。比如说读写锁
   
4. java中wait和sleep的区别与联系
   - 区别：
     1. 两者分别来自不同的类，wait是和锁相关的方法，而锁的信息是存储在对象头上的，因此wait是属于Object这个超类的。
        而sleep是针对线程的，所以sleep是属于Thread这个类。
        
5. 进程和线程的区别

6. 描述一下java线程的生命周期


7.说一下程序开多少线程合适

8.说一线notify和notifyAll的区别

9. 说一线synchronized和lock的区别

